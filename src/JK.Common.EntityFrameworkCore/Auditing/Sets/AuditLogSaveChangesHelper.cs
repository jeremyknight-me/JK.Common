using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace JK.Common.EntityFrameworkCore.Auditing.Sets
{
    ///<summary>Helper class to add change auditing for all entity sets.</summary>
    ///<remarks>When using SQL Server, consider using existing tools such as change data capture, change tracking, or temporal tables.</remarks>
    public sealed class AuditLogSaveChangesHelper
    {
        private readonly IAuditableContext context;

        public AuditLogSaveChangesHelper(IAuditableContext auditableContext)
        {
            this.context = auditableContext;
        }

        public IEnumerable<AuditEntry> OnBeforeSaveChanges()
        {
            this.context.ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            var detectedEntities = this.context.ChangeTracker.Entries()
                .Where(x => !(x.Entity is AuditLog) && x.State != EntityState.Detached && x.State != EntityState.Unchanged);
            foreach (var entry in detectedEntities)
            {
                const string annotationKey = "Relational:TableName";
                var tableNameAnnotation = entry.Metadata.FindAnnotation(annotationKey)?.Value?.ToString() ?? string.Empty;
                var tableName = string.IsNullOrWhiteSpace(tableNameAnnotation)
                    ? entry.Metadata.DisplayName()
                    : tableNameAnnotation;
                var auditEntry = new AuditEntry(entry)
                {
                    TableName = tableName,
                    EventType = entry.State.ToString()
                };
                auditEntries.Add(auditEntry);

                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified)
                            {
                                auditEntry.OldValues[propertyName] = property.OriginalValue;
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }
            }

            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties))
            {
                this.context.AuditLogs.Add(auditEntry.ToAuditLog());
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return auditEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }

        public void OnAfterSaveChanges(IEnumerable<AuditEntry> auditEntries)
        {
            if (auditEntries == null || auditEntries.Count() == 0)
            {
                return;
            }

            this.ProcessAuditEntries(auditEntries);
            this.context.SaveChanges();
        }

        public Task OnAfterSaveChangesAsync(IEnumerable<AuditEntry> auditEntries)
        {
            if (auditEntries == null || auditEntries.Count() == 0)
            {
                return Task.CompletedTask;
            }

            this.ProcessAuditEntries(auditEntries);
            return this.context.SaveChangesAsync();
        }

        private void ProcessAuditEntries(IEnumerable<AuditEntry> auditEntries)
        {
            foreach (var auditEntry in auditEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                this.context.AuditLogs.Add(auditEntry.ToAuditLog());
            }
        }
    }
}
